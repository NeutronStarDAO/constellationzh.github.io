<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Post模块 - 互联网计算机漫游指南</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The constellation book for you.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.png">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/style.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../about.html">👽互联网计算机漫游指南🛸</a></li><li class="chapter-item affix "><li class="part-title">去中心化之旅🔍</li><li class="chapter-item "><a href="../0.去中心化之旅/造梦家的冒险之旅.html">造梦家的冒险之旅</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../0.去中心化之旅/未来已来.html">未来已来</a></li><li class="chapter-item "><a href="../0.去中心化之旅/加密朋克的那些事.html">加密朋克的那些事</a></li><li class="chapter-item "><a href="../0.去中心化之旅/区块链是啥？.html">区块链是啥？</a></li><li class="chapter-item "><a href="../0.去中心化之旅/什么是以太坊？.html">什么是以太坊？</a></li><li class="chapter-item "><a href="../0.去中心化之旅/我的网络隐私呢？.html">我的网络隐私呢？</a></li><li class="chapter-item "><a href="../0.去中心化之旅/比特币.html">比特币</a></li></ol></li><li class="chapter-item "><li class="part-title">了解IC📡</li><li class="chapter-item "><a href="../1.了解IC/1.了解IC.html">了解IC</a></li><li class="chapter-item "><a href="../1.了解IC/ICP=Web3.0.html">ICP = Web 3.0</a></li><li class="chapter-item affix "><li class="part-title">核心协议⭐</li><li class="chapter-item "><a href="../2.核心协议/1.P2P层.html">P2P层</a></li><li class="chapter-item "><a href="../2.核心协议/2.共识层.html">共识层</a></li><li class="chapter-item "><a href="../2.核心协议/3.消息路由层.html">消息路由层</a></li><li class="chapter-item "><a href="../2.核心协议/4.执行层.html">执行层</a></li><li class="chapter-item "><a href="../2.核心协议/相关概念介绍/简介.html">相关概念</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../2.核心协议/相关概念介绍/共识委员会数量如何确定？.html">共识委员会数量如何确定？</a></li><li class="chapter-item "><a href="../2.核心协议/相关概念介绍/P2P层是如何降低恶意攻击的？.html">P2P层是如何降低恶意攻击的？</a></li></ol></li><li class="chapter-item "><li class="part-title">链钥密码学🪄</li><li class="chapter-item "><a href="../3.链钥密码学(ChainKey)/1.ChainKey.html">Chain Key</a></li><li class="chapter-item "><a href="../3.链钥密码学(ChainKey)/VetKeys.html">VETKeys</a></li><li class="chapter-item affix "><li class="part-title">容器🧰</li><li class="chapter-item "><a href="../4.容器(Canister)/1.Canister.html">Canister</a></li><li class="chapter-item "><a href="../4.容器(Canister)/2.Motoko.html">Motoko</a></li><li class="chapter-item "><a href="../4.容器(Canister)/3.部署自己的Canister.html">部署Canister</a></li><li class="chapter-item "><a href="../4.容器(Canister)/4.XRC.html">XRC</a></li><li class="chapter-item affix "><li class="part-title">网络神经系统(NNS)⚙️</li><li class="chapter-item "><a href="../5.网络神经系统(NNS)/1.NNS.html">NNS</a></li><li class="chapter-item "><a href="../5.网络神经系统(NNS)/2.DAO.html">DAO</a></li><li class="chapter-item "><a href="../5.网络神经系统(NNS)/3.经济模型.html">经济模型</a></li><li class="chapter-item affix "><li class="part-title">区块链网络服务🎯</li><li class="chapter-item "><a href="../6.区块链网络服务/5.可信执行环境.html">可信执行环境</a></li><li class="chapter-item "><a href="../6.区块链网络服务/6.链上随机数.html">链上随机数</a></li><li class="chapter-item affix "><li class="part-title">互联网身份🔑</li><li class="chapter-item "><a href="../7.互联网身份/1.ii.html">互联网身份</a></li><li class="chapter-item "><a href="../7.互联网身份/3.pid.html">pid</a></li><li class="chapter-item affix "><li class="part-title">IC里的密码学🔒</li><li class="chapter-item "><a href="../8.IC里的密码学/基础密码学知识.html">基础密码学介绍</a></li><li class="chapter-item "><a href="../8.IC里的密码学/BLS签名.html">BLS</a></li><li class="chapter-item "><a href="../8.IC里的密码学/秘密共享.html">秘密共享</a></li><li class="chapter-item "><a href="../8.IC里的密码学/哈希算法.html">哈希算法</a></li><li class="chapter-item affix "><li class="part-title">开发DApp🌟</li><li class="chapter-item "><a href="../9.Dapp开发/安装开发环境.html">安装开发环境</a></li><li class="chapter-item "><a href="../9.Dapp开发/dfx常用命令.html">dfx常用命令</a></li><li class="chapter-item "><a href="../9.Dapp开发/Motoko.html">Motoko</a></li><li class="chapter-item "><a href="../9.Dapp开发/1.入门DApp.html">入门DApp</a></li><li class="chapter-item "><a href="../9.Dapp开发/2.设计DApp.html">设计DApp</a></li><li class="chapter-item "><a href="../9.Dapp开发/3.开发Proton.html">开发Proton</a></li><li class="chapter-item "><a href="../9.Dapp开发/4.User模块.html">User模块</a></li><li class="chapter-item expanded "><a href="../9.Dapp开发/5.Post模块.html" class="active">Post模块</a></li><li class="chapter-item "><a href="../9.Dapp开发/6.Feed模块.html">Feed模块</a></li><li class="chapter-item "><a href="../9.Dapp开发/7.Fetch模块.html">Fetch模块</a></li><li class="chapter-item "><a href="../9.Dapp开发/8.共享类型.html">共享类型</a></li><li class="chapter-item "><a href="../9.Dapp开发/9.完成.html">完成</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="../词汇表.html">词汇表</a></li><li class="chapter-item affix "><a href="../贡献者名单.html">贡献者名单</a></li><li class="chapter-item affix "><a href="../参考资料.html">参考资料</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">互联网计算机漫游指南</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/NeutronStarDAO/ConstellationBook-Chinese" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                    // Get viewed page store
                    var viewed_key = 'mdbook-viewed';
                    var viewed_map = {};
                    try {
                        var viewed_storage = localStorage.getItem(viewed_key);
                        if (viewed_storage) {
                            viewed_map = JSON.parse(viewed_storage)
                        }
                    } catch (e) { }

                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                        
                        // Apply viewed style
                        if (viewed_map[link.pathname]) {
                            link.classList.add('md-viewed')
                        }
                    }); 

                    // Mark viewed after 30s
                    setTimeout(function() {
                        viewed_map[location.pathname] = 1;
                        localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                    }, 30000)
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h2 id="post"><a class="header" href="#post">Post</a></h2>
<p>用户通过 Feed 发布和获取动态，所有的帖子都存在 Bucket 里。通知抓取的功能则通过 Fetch 进行处理。</p>
<p>我们下一个要实现的是 Post 模块。但是我们需要用的类型有帖子、点赞、评论，还要和其他 Canister 交互，而且这些类型在 Feed 、Fetch 里还需要用。</p>
<p>所以对于要全局共享的类型，我们可以把它放在模块文件夹之外：</p>
<pre><code>src
  ├── feed
  ├── fetch
  ├── post
  ├── user
  ├── types.mo  👈
  └── utils.mo
</code></pre>
<p>在使用时先把 types.mo 的内容引用到模块文件夹内的 types.mo 里。再引入其他文件里。</p>
<br>
<p>比如把帖子这个类型定义好：代表了用户发布的帖子，然后放到外层文件夹的 types.mo 里，具体可以看 <a href="./8.%E5%85%B1%E4%BA%AB%E7%B1%BB%E5%9E%8B.html">8.共享类型</a> 。帖子包括了很多信息，比如帖子的 ID 、发布者、帖子索引、发布时间、内容、点赞数、评论等等。</p>
<pre><code class="language-motoko">public type Post = {
    postId: PostId;
    feedCanister: Principal;
    index: Nat;
    user: UserId;
    content: Text;
    var repost: [Repost];
    var like: [Like];
    var comment: [Comment];
    createdAt: Time;
};
</code></pre>
<br>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231120173647549.png" style="zoom:45%;" />
</div>
<p>根据之前的设计，在 Post 模块里有 2 种 Canister ：Root Post 和 Bucket 。</p>
<p>Root Post 负责统筹管理所有的 Bucket ：</p>
<ul>
<li>
<p>创建足够多的 Bucket （始终保持 5 个可用）。</p>
</li>
<li>
<p>查询所有 Bucket 、可用的 Bucket 、已存满的 Bucket 等。</p>
</li>
</ul>
<br>
<p>Bucket 是直接存储帖子内容的地方：</p>
<ul>
<li>
<p>存储帖子。</p>
</li>
<li>
<p>查询帖子总数量、根据帖子 ID 查询单个帖子、查询多个帖子、获取最新帖子。</p>
</li>
<li>
<p>在收到新评论后，通过 CommentFetch 通知。</p>
</li>
<li>
<p>同样维护了两个子模块的地址，提供了更新和查询这两个 Canister 的函数。</p>
</li>
<li>
<p>Bucket 通过 <code>checkBucketMemory</code> 函数检查帖子数量，当接近阈值时通知根帖子模块重新创建 Bucket 。</p>
</li>
</ul>
<br>
<h3 id="管理canisterrootpostmo"><a class="header" href="#管理canisterrootpostmo">管理Canister：rootPost.mo</a></h3>
<p>看看 Root Post Canister 。Root Post 需要管理 Bucket，我们可以用 <code>TrieMap</code> 记录。用 <code>TrieMap</code> 记录三种不同状态的 Bucket ：<code>buckets</code> 存储所有已创建的 Bucket ，<code>availableBuckets</code> 存储可用的 Bucket ，<code>unavailableBuckets</code> 存储已经存满的 Bucket 。</p>
<p>因为部署 Canister 之后需要先创建 5 个 Canister ，我们还需要初始化函数，以及后续可以新增 Bucket 。在创建 Bucket 时，还得告诉 Bucket 系统中的 Comment Fetch 和 Like Fetch 的 Canister ID ，所以在 Root Post 中，我们还要记录、保存 Comment Fetch 和 Like Fetch 。</p>
<p>最后是查询所有 Bucket 、查询可用的 Bucket 、查询已经存满的 Bucket 。</p>
<br>
<p>先定义一些 stable 变量和映射来保存 Bucket 。</p>
<p>在 Motoko 中，<code>stable</code> 关键字用于定义稳定变量（Stable variables）。这些变量的值应在 Canister 升级过程中保持持久性。这是 Motoko 特有的功能，它使用 ICP 的稳定内存（Stable memory）来在 Canister 升级过程中保持数据的持久性。稳定内存是 IC 可以长期存储数据的特性，不受语言限制， Motoko 、Rust 或任何其他语言写的 Canister 都可以用。稳定内存可以容纳高达 400 GiB 的数据，如果子网可以容纳的话。</p>
<p>通过这些 stable 变量和映射的定义，可以持久化保存多个 Bucket 的状态、总量等信息，并在 Canister 升级后继续使用，实现了 Bucket 管理的持久化。</p>
<pre><code class="language-js">stable let T_CYCLES = 1_000_000_000_000; // 提前定义好1T Cycles，方便后续使用
stable let BUCKET_MAX_POST_NUMBER: Nat = 5000; // 记录每个Bucket可以存储的最大帖子数
stable var bucketIndex: Nat = 0; // bucketIndex记录已经创建的Bucket数量

// 定义一个数组，保存所有已经创建的Bucket的信息
stable var bucketsEntries: [(Nat, Principal)] = [];
// buckets是根据bucketsEntries创建的映射表，键是索引，值是Bucket的principal
let buckets = TrieMap.fromEntries&lt;Nat, Principal&gt;(bucketsEntries.vals(), Nat.equal, Hash.hash);

// availableBucketsEntries和availableBuckets用于记录当前可用的Bucket
stable var availableBucketsEntries: [(Nat, Principal)] = [];
let availableBuckets = TrieMap.fromEntries&lt;Nat, Principal&gt;(availableBucketsEntries.vals(), Nat.equal, Hash.hash);

// unavailableBucketsEntries和unavailableBuckets用于记录当前不可用的Bucket
stable var unavailableBucketsEntries: [(Nat, Principal)] = [];
let unavailableBuckets = TrieMap.fromEntries&lt;Nat, Principal&gt;(unavailableBucketsEntries.vals(), Nat.equal, Hash.hash);
</code></pre>
<br>
<p><code> _createBucket()</code> 函数创建 Canister ：</p>
<p>使用 Bucket.Bucket 对象的 Bucket 函数创建一个新的 Bucket actor ，传入 Root Post Canister 的 principal（ ID ） 、commentFetchCanister 和 likeFetchCanister 作为参数。</p>
<pre><code class="language-js">// 创建Bucket的逻辑
private func _createBucket(): async Principal {
    // 给每个Bucket添加4T Cycles
    Cycles.add(4 * T_CYCLES);
    let newBucket = await Bucket.Bucket(
        Principal.fromActor(this),
        commentFetchCanister,
        likeFetchCanister
    );

    // 将新创建的Bucket的principal保存到buckets映射表中，键为当前的bucketIndex
    buckets.put(bucketIndex, Principal.fromActor(newBucket));
    // 同时也保存到availableBuckets映射表中，表示这个Bucket当前可用
    availableBuckets.put(bucketIndex, Principal.fromActor(newBucket));

    // bucketIndex加1，表示已创建Bucket数量增加
    bucketIndex += 1;
    
    // 返回新创建的Bucket的principal
    Principal.fromActor(newBucket)
};
</code></pre>
<p>这样 <code>_createBucket()</code> 函数就可以创建一个新的 Bucket Actor ，并保存它的 principal 到两个映射表中表示已创建和可用状态。</p>
<p>它封装了创建 Bucket 的具体逻辑，作为一个私有函数被 <code>createBucket()</code> 公开函数调用。使用 <code>bucketIndex</code> 标识每个 Bucket，并在创建后增加该索引。</p>
<p>我们可以方便地批量创建 Bucket ，并明确其状态，也为管理多个 Bucket 提供了便利。</p>
<br>
<p>接下来继续构建创建和管理多个 Bucket 的函数。</p>
<pre><code class="language-js">// 开始先创建5个Bucket，并把它们添加到buckets和availableBuckets的映射表中
public shared({caller}) func init(): async () {
    var i = 0;
    label l loop {
        if(i &gt;= 5) break l;

        Cycles.add(4 * T_CYCLES);
        let newBucket = await Bucket.Bucket(
            Principal.fromActor(this),
            commentFetchCanister,
            likeFetchCanister
        );

        buckets.put(bucketIndex, Principal.fromActor(newBucket));
        availableBuckets.put(bucketIndex, Principal.fromActor(newBucket));
        bucketIndex += 1;

        i += 1;
    };
};

// 批量添加已经创建好的Bucket到buckets和availableBuckets中
public shared({caller}) func addAvailBucket(bucketArray: [Principal]): async () {
    for(_bucket in bucketArray.vals()) {
        buckets.put(bucketIndex, _bucket);
        availableBuckets.put(bucketIndex, _bucket);
        bucketIndex += 1;
    };
};

// 返回当前已经创建的Bucket数量
public query func getBucketIndex(): async Nat { bucketIndex };

// 公开创建Bucket的函数，内部调用_createBucket()
public shared({caller}) func createBucket(): async Principal {
    await _createBucket()
};
</code></pre>
<p>现在我们的一个 Canister 可以管理 Bucket 的创建、添加了。所有 Bucket 的创建和生命周期能够被集中管理。</p>
<br>
<p>之后还要写出查询函数：</p>
<pre><code class="language-js">// 查询可用的Bucket
public query func getAvailableBucket(): async ?Principal {
    if(availableBuckets.size() == 0) return null;
    availableBuckets.get(Nat.rem(Option.unwrap(Nat.fromText(Int.toText(Time.now()))), availableBuckets.size()))
};

// 查询所有的Bucket
public query func getAllBuckets(): async [Principal] {
    Iter.toArray(buckets.vals())
};

// 查询所有可用的Bucket
public query func getAllAvailableBuckets(): async [Principal] {
    Iter.toArray(availableBuckets.vals())
};

// 查询已经存满的Bucket
public query func getAllUnavailableBuckets(): async [Principal] {
    Iter.toArray(unavailableBuckets.vals())
};
</code></pre>
<br>
<p>在创建 Bucket 时，我们还得告诉 Bucket 系统中的 Comment Fetch 和 Like Fetch 的 Canister ID ，所以在 Root Post 中，我们还要记录、保存 Comment Fetch 和 Like Fetch ：</p>
<pre><code class="language-js">// 持久化保存commentFetch canister的principal id
stable var commentFetchCanister = _commentFetchCanister;

// 外部可以查询当前保存的commentFetch canister id
public query func getCommentFetchCanister(): async Principal { commentFetchCanister };

// 授权特定的caller更新保存的commentFetch canister id
public shared({caller}) func updateCommentFetchCanister(
    newCommentFetchCanister: Principal
): async () {
    commentFetchCanister := commentFetchCanister;
};
</code></pre>
<p>现在 likeFetch canister 的 principal ID 可以被持久化保存，并可以通过 update 函数灵活更新，还能被外部程序读取查询。</p>
<pre><code class="language-js">// 持久化保存likeFetch canister的principal id
stable var likeFetchCanister = _likeFetchCanister;
    
// 外部可以查询当前保存的likeFetch canister id
public query func getLikeFetchCanister(): async Principal { likeFetchCanister };

// 授权特定的caller更新保存的likeFetch canister id
public shared({caller}) func updateLikeFetchCanister(
    newLikeFetchCanister: Principal
): async () {
    likeFetchCanister := newLikeFetchCanister;
};
</code></pre>
<br>
<p>最后是两个系统函数 <code>preupgrade()</code> 和 <code>postupgrade()</code> ，用来在 Canister 升级前后保存和重置 buckets 、availableBuckets 和 unavailableBuckets 的 entries 。</p>
<pre><code class="language-js">system func preupgrade() {
    bucketsEntries := Iter.toArray(buckets.entries());
    availableBucketsEntries := Iter.toArray(availableBuckets.entries());
    unavailableBucketsEntries := Iter.toArray(unavailableBuckets.entries());
};

system func postupgrade() {
    bucketsEntries := [];
    availableBucketsEntries := [];
    unavailableBucketsEntries := [];
};
</code></pre>
<p><code>preupgrade()</code> 函数在 Canister 升级前被调用，它将 buckets 、availableBuckets 和 unavailableBuckets 中的所有 entries 保存到对应的数组 bucketsEntries 、availableBucketsEntries 和 unavailableBucketsEntries 中。</p>
<p><code>postupgrade()</code> 函数在 Canister 升级后被调用，它将 bucketsEntries 、availableBucketsEntries 和 unavailableBucketsEntries 数组清空，相当于重置了 buckets 、availableBuckets 和 unavailableBuckets 中的数据。</p>
<p>这样，通过在升级前后保存和重置 entries ，可以使 buckets 、availableBuckets 和 unavailableBuckets 中的数据在 Canister 升级后不丢失。</p>
<p><code>preupgrade</code> 和 <code>postupgrade</code> 被定义为系统函数，会由 Runtime 自动调用，开发者不需要自己调用。</p>
<p>这段代码实现了 Canister 升级的数据迁移，通过在升级前后保存和重置状态，保证了 Canister 升级的透明性。</p>
<br>
<div class="center-image">
<img src="assets/5.Post模块/image-20240130131002611.png" alt="image-20240130131002611" style="zoom:39%;" />
</div>
<p>以下是 rootPost.mo 的完整文件：</p>
<pre><code class="language-js">import Hash &quot;mo:base/Hash&quot;;
import Nat &quot;mo:base/Nat&quot;;
import TrieMap &quot;mo:base/TrieMap&quot;;
import Principal &quot;mo:base/Principal&quot;;
import Types &quot;./types&quot;;
import Bucket &quot;./bucket&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Cycles &quot;mo:base/ExperimentalCycles&quot;;
import Time &quot;mo:base/Time&quot;;
import Int &quot;mo:base/Int&quot;;
import Option &quot;mo:base/Option&quot;;
import IC &quot;mo:ic&quot;;

actor class RootPost(
    _commentFetchCanister: Principal,
    _likeFetchCanister: Principal
) = this {

    stable let T_CYCLES = 1_000_000_000_000;
    stable let BUCKET_MAX_POST_NUMBER: Nat = 5000; // 每个Bucket可以存储的最大帖子数
    stable var bucketIndex: Nat = 0;

    stable var bucketsEntries: [(Nat, Principal)] = [];
    let buckets = TrieMap.fromEntries&lt;Nat, Principal&gt;(bucketsEntries.vals(), Nat.equal, Hash.hash);

    stable var availableBucketsEntries: [(Nat, Principal)] = [];
    let availableBuckets = TrieMap.fromEntries&lt;Nat, Principal&gt;(availableBucketsEntries.vals(), Nat.equal, Hash.hash);

    stable var unavailableBucketsEntries: [(Nat, Principal)] = [];
    let unavailableBuckets = TrieMap.fromEntries&lt;Nat, Principal&gt;(unavailableBucketsEntries.vals(), Nat.equal, Hash.hash);

    // 开始先创建 5 个 Bucket
    public shared({caller}) func init(): async () {
        var i = 0;
        label l loop {
            if(i &gt;= 5) break l;

            Cycles.add(4 * T_CYCLES);
            let newBucket = await Bucket.Bucket(
                Principal.fromActor(this),
                commentFetchCanister,
                likeFetchCanister
            );

            buckets.put(bucketIndex, Principal.fromActor(newBucket));
            availableBuckets.put(bucketIndex, Principal.fromActor(newBucket));
            bucketIndex += 1;

            i += 1;
        };
    };

    public shared({caller}) func addAvailBucket(bucketArray: [Principal]): async () {
        for(_bucket in bucketArray.vals()) {
            buckets.put(bucketIndex, _bucket);
            availableBuckets.put(bucketIndex, _bucket);
            bucketIndex += 1;
        };
    };

    public query func getBucketIndex(): async Nat { bucketIndex };

    // 创建Bucket
    public shared({caller}) func createBucket(): async Principal {
        await _createBucket()
    };

    // 创建Bucket的逻辑
    private func _createBucket(): async Principal {
        Cycles.add(4 * T_CYCLES);
        let newBucket = await Bucket.Bucket(
            Principal.fromActor(this),
            commentFetchCanister,
            likeFetchCanister
        );

        buckets.put(bucketIndex, Principal.fromActor(newBucket));
        availableBuckets.put(bucketIndex, Principal.fromActor(newBucket));

        bucketIndex += 1;

        Principal.fromActor(newBucket)
    };

    public shared({caller}) func reCreateBucket(): async () {
        for((_key, _bucket) in availableBuckets.entries()) {
            if(_bucket == caller) {
                ignore await _createBucket();
                availableBuckets.delete(_key);
                unavailableBuckets.put(_key, _bucket);
            };
        };
    };

    // 查询可用的Bucket
    public query func getAvailableBucket(): async ?Principal {
        if(availableBuckets.size() == 0) return null;
        availableBuckets.get(Nat.rem(Option.unwrap(Nat.fromText(Int.toText(Time.now()))), availableBuckets.size()))
    };

    // 查询所有的Bucket
    public query func getAllBuckets(): async [Principal] {
        Iter.toArray(buckets.vals())
    };

    public query func getAllAvailableBuckets(): async [Principal] {
        Iter.toArray(availableBuckets.vals())
    };

    // 查询已经存满的Bucket
    public query func getAllUnavailableBuckets(): async [Principal] {
        Iter.toArray(unavailableBuckets.vals())
    };

// ==================== CommentFetchCanister ====================

    stable var commentFetchCanister = _commentFetchCanister;
    
    public query func getCommentFetchCanister(): async Principal { commentFetchCanister };

    public shared({caller}) func updateCommentFetchCanister(
        newCommentFetchCanister: Principal
    ): async () {
        commentFetchCanister := commentFetchCanister;
    };


// ==================== LikeFetchCanister ====================

    stable var likeFetchCanister = _likeFetchCanister;
    
    public query func getLikeFetchCanister(): async Principal { likeFetchCanister };

    public shared({caller}) func updateLikeFetchCanister(
        newLikeFetchCanister: Principal
    ): async () {
        likeFetchCanister := newLikeFetchCanister;
    };

    system func preupgrade() {
        bucketsEntries := Iter.toArray(buckets.entries());
        availableBucketsEntries := Iter.toArray(availableBuckets.entries());
        unavailableBucketsEntries := Iter.toArray(unavailableBuckets.entries());
    };

    system func postupgrade() {
        bucketsEntries := [];
        availableBucketsEntries := [];
        unavailableBucketsEntries := [];
    };
}
</code></pre>
<br>
<h3 id="存储帖子bucketmo"><a class="header" href="#存储帖子bucketmo">存储帖子：bucket.mo</a></h3>
<p>Bucket 是存储帖子的 Canister ，每个 Bucket 可以存储一定数量的帖子。支持存储、查询、更新帖子以及通知 Fetch Canister 的功能。</p>
<p>Bucket 需要提供了查询帖子数量、根据帖子 ID 查询单个帖子、查询多个帖子、获取最新帖子的函数。</p>
<p>在收到新评论、点赞之后，Bucket 还要通过 Comment Fetch Canister 和 Like Fetch Canister 。</p>
<p>当 Bucket 存储的帖子数量接近阈值时，Root Post 会创建新的 Bucket 。</p>
<br>
<p>这是 <code>Bucket</code> 模块的开始，它是实际存储帖子的地方。带有 <code>actor class</code> 关键字的表示这是一个可以被外部调用的 Actor 类。带有 <code>(rootPostCanister, _commentFetchCanister, _likeFetchCanister)</code> 参数表示这个 Actor 类需要初始化时传入这三个 Canister 的 ID 。</p>
<pre><code class="language-js">actor class Bucket(
    rootPostCanister: Principal,
    _commentFetchCanister: Principal,
    _likeFetchCanister: Principal
) = this {
    // ...
};
</code></pre>
<br>
<p>整体上这个 Bucket 用于接收各种操作（新评论、点赞等）来更新帖子，所有数据以不可变形式存储，可以高效地进行查询和共享。</p>
<p>首先定义一些类型、变量和数据结构。</p>
<pre><code class="language-js">// 定义了几个类型别名
type FeedActor = Types.FeedActor;
type PostImmutable = Types.PostImmutable;
type NewComment = Types.NewComment;
type NewLike = Types.NewLike;
type NewRepost = Types.NewRepost;
type CommentFetchActor = Types.CommentFetchActor;
type LikeFetchActor = Types.LikeFetchActor;
type RootPostActor = Types.RootPostActor;

stable let BUCKET_MAX_POST_NUMBER: Nat = 5000; // 每个Bucket可以存储的最大帖子数
stable let FLOOR_BUCKET_MAX_POST_NUMBER: Nat = BUCKET_MAX_POST_NUMBER - 50; // 一个下限阈值

stable let installer = msg.caller;

// postId -&gt; PostImmutable
// 主要的数据存储在feedMap中，这是一个从帖子ID到PostImmutable的映射
stable var feedMapEntries: [(Text, PostImmutable)] = [];
// 存储在TrieMap中，使用Text哈希和比较
let feedMap = TrieMap.fromEntries&lt;Text, PostImmutable&gt;(feedMapEntries.vals(), Text.equal, Text.hash);
</code></pre>
<p><code>TrieMap</code> 是一种高效的键值存储结构。使用 <code>TrieMap</code> 维护了帖子信息，提供了存储、批量存储、更新评论、更新点赞、更新转发等功能。<code>feedMapEntries</code> 和 <code>feedMap</code> 的定义用来存储帖子数据，一个是数组形式，一个是 TrieMap 形式。</p>
<br>
<p>存储帖子：</p>
<p><code>storeFeed()</code> 函数用来存储单个帖子。它是 <code>public shared</code> 的，所以可以被外部调用者调用。</p>
<pre><code class="language-js">public shared({caller}) func storeFeed(post: PostImmutable): async Bool {
    ignore checkBucketMemory();
    _storeFeed(post);
};
</code></pre>
<p><code>batchStoreFeed()</code> 用于批量存储多篇帖子，内部使用循环调用 <code>_storeFeed()</code> 逐个存储。</p>
<pre><code class="language-js">public shared({caller}) func batchStoreFeed(posts: [PostImmutable]): async () {
    for(post in posts.vals()) {
        ignore _storeFeed(post);
    };
};
</code></pre>
<p><code>updatePostRepost()</code> 用来更新一个帖子的转发信息。它会调用 <code>_updatePostRepost()</code> 执行实际的更新，并 assert 确保更新成功。</p>
<pre><code class="language-js">public shared({caller}) func updatePostRepost(postId: Text, newRepost: NewRepost): async Bool {
    assert(_updatePostRepost(postId, newRepost));
    true
};
</code></pre>
<p><code>_storeFeed()</code> 和 <code>_updatePostRepost()</code> 是私有函数，是实际实现存储和更新的内部逻辑。</p>
<br>
<p>接下来是更新帖子评论和点赞的功能：</p>
<p><code>updatePostComment</code> 函数用于更新帖子的评论信息。它接收帖子 ID 和新的评论作为参数。内部调用 <code>_updatePostComment</code> 函数去实际执行评论的更新。</p>
<p>更新成功后，会从 <code>_updatePostComment</code> 返回更新后的 post 对象。然后通知 <code>CommentFetchActor</code> 去更新评论缓存。</p>
<p><code>updatePostLike</code> 函数用于更新帖子的点赞信息。它接收帖子 ID 和新的点赞作为参数。内部调用 <code>_updatePostLike</code> 去实际执行点赞的更新。 </p>
<p>更新成功后，同样返回更新后的 post 对象，并通知 <code>LikeFetchActor</code> 去更新点赞缓存。</p>
<pre><code class="language-js">// 更新帖子评论信息
// caller参数表示：只有调用者的请求中给出正常身份，才能调用函数
public shared({caller}) func updatePostComment(postId: Text, newComment: NewComment): async Bool {
    switch(_updatePostComment(postId, newComment)) {
        case(null) { return false; };
        case(?_post) {
            // 通知 commentFetch
            let commentFetchActor: CommentFetchActor = actor(Principal.toText(commentFetchCanister));
            ignore commentFetchActor.receiveNotify(_post);
        };
    };
    // 返回Bool值表示更新是否成功
    true
};

public shared({caller}) func updatePostLike(postId: Text, newLike: NewLike): async Bool {
    switch(_updatePostLike(postId, newLike)) {
        case(null) { return false; };
        case(?_post) {
            // 通知 likeFetch
            let likeFetchActor: LikeFetchActor = actor(Principal.toText(likeFetchCanister));
            ignore likeFetchActor.receiveNotify(_post);
        };     
    };
    true
};
</code></pre>
<p>我们通过私有函数实现对操作帖子函数的封装。外部只需要调用公开的 update 函数，不需要关心内部的存储和更新逻辑。 私有函数可以封装状态管理，使代码更加模块化和可维护。</p>
<br>
<p><code>_updatePostComment</code> 函数用于更新帖子的评论。它从 <code>feedMap</code> 中获取原有的帖子，用新评论 <code>newComment</code> 更新 <code>comment</code> 字段，并 put 回<code>feedMap</code> 。</p>
<p><code>feedMap</code> 是一个存储帖子的哈希表，key 是 <code>postId</code> ，value 是 <code>PostImmutable</code> 记录。</p>
<pre><code class="language-js">private func _updatePostComment(postId: Text, newComment: NewComment): ?PostImmutable {
    switch(feedMap.get(postId)) {
        case(null) { return null; };
        case(?post) {
            let _newPost = {
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                repost = post.repost;
                content = post.content;
                like = post.like;
                comment = newComment;
                createdAt = post.createdAt;
            };
            feedMap.put(postId, _newPost);
            ?_newPost
        };
    };
};
</code></pre>
<br>
<p><code>_updatePostLike</code> 类似地更新帖子的点赞 like 字段。 </p>
<pre><code class="language-js">private func _updatePostLike(postId: Text, newLike: NewLike): ?PostImmutable {
    switch(feedMap.get(postId)) {
        case(null) { return null; };
        case(?post) {
            let _newPost = {
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                repost = post.repost;
                content = post.content;
                like = newLike;
                comment = post.comment;
                createdAt = post.createdAt;
            };
            feedMap.put(postId, _newPost);
            ?_newPost              
        };
    };
};
</code></pre>
<br>
<p><code>_updatePostRepost</code> 更新帖子的转发 repost 字段。</p>
<pre><code class="language-js">private func _updatePostRepost(postId: Text, newRepost: NewRepost): Bool {
    switch(feedMap.get(postId)) {
        case(null) { return false; };
        case(?post) {
            feedMap.put(postId, {
                postId = post.postId;
                feedCanister = post.feedCanister;
                index = post.index;
                user = post.user;
                content = post.content;
                repost = newRepost;
                like = post.like;
                comment = post.comment;
                createdAt = post.createdAt;
            });
            true
        };
    };
};
</code></pre>
<br>
<p>使用 <code>immutable</code> 数据结构 <code>PostImmutable</code> 可以保证数据一致性，避免意外修改。</p>
<pre><code class="language-js">// 把新的帖子保存到feedMap中
// 检查postId是否已存在，如果不存在才保存，避免重复
private func _storeFeed(post: PostImmutable): Bool {
    ignore Utils.checkPostId(post.postId);
    switch(feedMap.get(post.postId)) {
        case(?_post) {
            // Debug.print(&quot;This post has been stored&quot;);
            return false;
        };
        case(null) {
            feedMap.put(post.postId, post);
            return true;
        };
    };
};
</code></pre>
<br>
<p><code>checkBucketMemory</code> 函数用于检查当前 Bucket 是否接近容量上限，如果是，则通知根帖子 Actor 创建新的 Bucket 。</p>
<pre><code class="language-js">func checkBucketMemory(): async () {
    if(feedMap.size() &gt; FLOOR_BUCKET_MAX_POST_NUMBER) {
        let rootPostActor: RootPostActor = actor(Principal.toText(rootPostCanister));
        ignore rootPostActor.reCreateBucket();
    }
};
</code></pre>
<br>
<p>我们需要一个查询帖子总数的函数：</p>
<pre><code class="language-js">// 查询共有多少个帖子
public query func getPostNumber(): async Nat {
    feedMap.size()
};
</code></pre>
<br>
<p>还有获取帖子具体内容的函数，实现快速批量获取某几个帖子的功能。</p>
<p>这个功能用在 Feed Canister 抓取帖子上：</p>
<p>当用户关注的某几个人发布了帖子，这些帖子的 ID 又会被送到 Fetch ，最后发送到 另一个 Feed 里。这是 Feed 就会一次性收到很多个帖子的 ID ，Feed 就需要把这些帖子 ID 发给 Bucket ，一次性获取到这些帖子们。</p>
<pre><code class="language-js">// 根据ID查询某几个帖子（可以传入7个ID一次性返回7个帖子的内容）
public query func getPosts(postIdArray: [Text]): async [PostImmutable] { // 接收一个Text数组postIdArray作为参数
    // 创建一个Buffer来存储查询结果，大小为postIdArray的大小
    let result = Buffer.Buffer&lt;PostImmutable&gt;(postIdArray.size());
    // 遍历postIdArray中的每个ID
    for(postId in postIdArray.vals()) {
        // 对每个ID，从feedMap中查找，如果找到则放入结果Buffer中
        switch(feedMap.get(postId)) {
            case(null) {};
            case(?post) { result.add(post); };
        };
    };
        // 遍历结束后，通过toArray()转换Buffer为数组并返回
        Buffer.toArray&lt;PostImmutable&gt;(result)
};
</code></pre>
<p>我们使用 Buffer 避免多次数组拼接的开销。query 函数可以被链外调用，实现了数据查询的封装。 返回的是数组类型，调用方可以方便处理查询结果。</p>
<p>这样就可以批量查询多篇帖子内容了。</p>
<br>
<p>根据 ID 批量精确查询帖子之后，还需要 2 个关于查询的函数：根据 ID 单独查询帖子的函数和查询最新的 n 个帖子函数。</p>
<pre><code class="language-js">public query func getPost(postId: Text): async ?PostImmutable {
    switch(feedMap.get(postId)) {
        case(null) { return null; };
        case(?post) { return ?post; }; 
    };
};

// 查询最新的 n 个帖子
public query func getLatestFeed(n: Nat): async [PostImmutable] {
    let feedArray = Iter.toArray(
        Iter.sort&lt;PostImmutable&gt;(
        feedMap.vals(),
        func (x: PostImmutable, y: PostImmutable): Order.Order {
            if(x.createdAt &gt; y.createdAt) return #less
            else if(x.createdAt &lt; y.createdAt) return #greater
            else return #equal
    }));
    if(n &lt;= feedArray.size()) {
        Array.subArray(feedArray, 0, n)
    } else {
        Array.subArray(feedArray, 0, feedArray.size())
    }
};
</code></pre>
<p>最后是和升级有关的系统函数，通过 <code>preupgrade</code> 和 <code>postupgrade</code> 函数管理 Bucket 的状态。</p>
<br>
<p>以下是 bucket.mo 完整文件：</p>
<pre><code class="language-js">import Types &quot;./types&quot;;
import TrieMap &quot;mo:base/TrieMap&quot;;
import Principal &quot;mo:base/Principal&quot;;
import Array &quot;mo:base/Array&quot;;
import Order &quot;mo:base/Order&quot;;
import Text &quot;mo:base/Text&quot;;
import Hash &quot;mo:base/Hash&quot;;
import Nat &quot;mo:base/Nat&quot;;
import Iter &quot;mo:base/Iter&quot;;
import Debug &quot;mo:base/Debug&quot;;
import Option &quot;mo:base/Option&quot;;
import Buffer &quot;mo:base/Buffer&quot;;
import Utils &quot;../utils&quot;;

shared(msg) actor class Bucket(
    rootPostCanister: Principal,
    _commentFetchCanister: Principal,
    _likeFetchCanister: Principal
) = this {
    
    type FeedActor = Types.FeedActor;
    type PostImmutable = Types.PostImmutable;
    type NewComment = Types.NewComment;
    type NewLike = Types.NewLike;
    type NewRepost = Types.NewRepost;
    type CommentFetchActor = Types.CommentFetchActor;
    type LikeFetchActor = Types.LikeFetchActor;
    type RootPostActor = Types.RootPostActor;

    stable let BUCKET_MAX_POST_NUMBER: Nat = 5000; // 每个Bucket可以存储的最大帖子数 (待计算)
    stable let FLOOR_BUCKET_MAX_POST_NUMBER: Nat = BUCKET_MAX_POST_NUMBER - 50;

    stable let installer = msg.caller;

    // postId -&gt; PostImmutable
    stable var feedMapEntries: [(Text, PostImmutable)] = [];
    let feedMap = TrieMap.fromEntries&lt;Text, PostImmutable&gt;(feedMapEntries.vals(), Text.equal, Text.hash);

    // 存储帖子
    public shared({caller}) func storeFeed(post: PostImmutable): async Bool {
        ignore checkBucketMemory();
        _storeFeed(post);
    };

    public shared({caller}) func batchStoreFeed(posts: [PostImmutable]): async () {
        for(post in posts.vals()) {
            ignore _storeFeed(post);
        };
    };

    public shared({caller}) func updatePostRepost(postId: Text, newRepost: NewRepost): async Bool {
        assert(_updatePostRepost(postId, newRepost));
        true
    };

    // 更新帖子评论信息 
    public shared({caller}) func updatePostComment(postId: Text, newComment: NewComment): async Bool {
        switch(_updatePostComment(postId, newComment)) {
            case(null) { return false; };
            case(?_post) {
                // 通知 commentFetch
                let commentFetchActor: CommentFetchActor = actor(Principal.toText(commentFetchCanister));
                ignore commentFetchActor.receiveNotify(_post);
            };
        };
        true
    };

    public shared({caller}) func updatePostLike(postId: Text, newLike: NewLike): async Bool {
        switch(_updatePostLike(postId, newLike)) {
            case(null) { return false; };
            case(?_post) {
                // 通知 likeFetch
                let likeFetchActor: LikeFetchActor = actor(Principal.toText(likeFetchCanister));
                ignore likeFetchActor.receiveNotify(_post);
            };     
        };
        true
    };

    func checkBucketMemory(): async () {
        if(feedMap.size() &gt; FLOOR_BUCKET_MAX_POST_NUMBER) {
            let rootPostActor: RootPostActor = actor(Principal.toText(rootPostCanister));
            ignore rootPostActor.reCreateBucket();
        }
    };

    private func _updatePostComment(postId: Text, newComment: NewComment): ?PostImmutable {
        switch(feedMap.get(postId)) {
            case(null) { return null; };
            case(?post) {
                let _newPost = {
                    postId = post.postId;
                    feedCanister = post.feedCanister;
                    index = post.index;
                    user = post.user;
                    repost = post.repost;
                    content = post.content;
                    like = post.like;
                    comment = newComment;
                    createdAt = post.createdAt;
                };
                feedMap.put(postId, _newPost);
                ?_newPost
            };
        };
    };

    private func _updatePostLike(postId: Text, newLike: NewLike): ?PostImmutable {
        switch(feedMap.get(postId)) {
            case(null) { return null; };
            case(?post) {
                let _newPost = {
                    postId = post.postId;
                    feedCanister = post.feedCanister;
                    index = post.index;
                    user = post.user;
                    repost = post.repost;
                    content = post.content;
                    like = newLike;
                    comment = post.comment;
                    createdAt = post.createdAt;
                };
                feedMap.put(postId, _newPost);
                ?_newPost              
            };
        };
    };

    private func _updatePostRepost(postId: Text, newRepost: NewRepost): Bool {
        switch(feedMap.get(postId)) {
            case(null) { return false; };
            case(?post) {
                feedMap.put(postId, {
                    postId = post.postId;
                    feedCanister = post.feedCanister;
                    index = post.index;
                    user = post.user;
                    content = post.content;
                    repost = newRepost;
                    like = post.like;
                    comment = post.comment;
                    createdAt = post.createdAt;
                });
                true              
            };
        };
    };

    private func _storeFeed(post: PostImmutable): Bool {
        ignore Utils.checkPostId(post.postId);
        switch(feedMap.get(post.postId)) {
            case(?_post) {
                // Debug.print(&quot;This post has been stored&quot;);
                return false;
            };
            case(null) {
                feedMap.put(post.postId, post);
                return true;
            };
        };
    };

// ==================== 查询函数 ====================

    // 查询共有多少个帖子
    public query func getPostNumber(): async Nat {
        feedMap.size()
    };

    // 根据ID查询某几个帖子（可以传入 7 个 ID 一次性返回 7 个帖子的内容）
    public query func getPosts(postIdArray: [Text]): async [PostImmutable] {
       let result = Buffer.Buffer&lt;PostImmutable&gt;(postIdArray.size());
       for(postId in postIdArray.vals()) {
        switch(feedMap.get(postId)) {
            case(null) {};
            case(?post) { result.add(post); };
        };
       };
       Buffer.toArray&lt;PostImmutable&gt;(result)
    };

    public query func getPost(postId: Text): async ?PostImmutable {
        switch(feedMap.get(postId)) {
            case(null) { return null; };
            case(?post) { return ?post; }; 
        };
    };

    // 查询最新的 n 个帖子
    public query func getLatestFeed(n: Nat): async [PostImmutable] {
        let feedArray = Iter.toArray(
            Iter.sort&lt;PostImmutable&gt;(
            feedMap.vals(),
            func (x: PostImmutable, y: PostImmutable): Order.Order {
                if(x.createdAt &gt; y.createdAt) return #less
                else if(x.createdAt &lt; y.createdAt) return #greater
                else return #equal
        }));
        if(n &lt;= feedArray.size()) {
            Array.subArray(feedArray, 0, n)
        } else {
            Array.subArray(feedArray, 0, feedArray.size())
        }
    };

// ==================== CommentFetchCanister ====================

    stable var commentFetchCanister = _commentFetchCanister;
    
    public query func getCommentFetchCanister(): async Principal { commentFetchCanister };

    public shared({caller}) func updateCommentFetchCanister(
        newCommentFetchCanister: Principal
    ): async () {
        commentFetchCanister := commentFetchCanister;
    };


// ==================== LikeFetchCanister ====================

    stable var likeFetchCanister = _likeFetchCanister;
    
    public query func getLikeFetchCanister(): async Principal { likeFetchCanister };

    public shared({caller}) func updateLikeFetchCanister(
        newLikeFetchCanister: Principal
    ): async () {
        likeFetchCanister := newLikeFetchCanister;
    };

    system func preupgrade() {
        feedMapEntries := Iter.toArray(feedMap.entries());
    };

    system func postupgrade() {
        feedMapEntries := [];
    };
}
</code></pre>
<p>然后是 <a href="./6.Feed%E6%A8%A1%E5%9D%97.html">Feed 模块</a>。</p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../9.Dapp开发/4.User模块.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../9.Dapp开发/6.Feed模块.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../9.Dapp开发/4.User模块.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../9.Dapp开发/6.Feed模块.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "9.Dapp开发/5.Post模块.md"
        </script>


        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../assets/custom.js"></script>
        <script type="text/javascript" src="../assets/bigPicture.js"></script>


    </body>
</html>