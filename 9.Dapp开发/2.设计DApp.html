<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>设计DApp - 互联网计算机漫游指南</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The constellation book for you.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.png">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/style.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../about.html">👽互联网计算机漫游指南🛸</a></li><li class="chapter-item affix "><li class="part-title">去中心化之旅🔍</li><li class="chapter-item "><a href="../0.去中心化之旅/造梦家的冒险之旅.html">造梦家的冒险之旅</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../0.去中心化之旅/未来已来.html">未来已来</a></li><li class="chapter-item "><a href="../0.去中心化之旅/加密朋克的那些事.html">加密朋克的那些事</a></li><li class="chapter-item "><a href="../0.去中心化之旅/区块链是啥？.html">区块链是啥？</a></li><li class="chapter-item "><a href="../0.去中心化之旅/什么是以太坊？.html">什么是以太坊？</a></li><li class="chapter-item "><a href="../0.去中心化之旅/我的网络隐私呢？.html">我的网络隐私呢？</a></li><li class="chapter-item "><a href="../0.去中心化之旅/比特币.html">比特币</a></li></ol></li><li class="chapter-item "><li class="part-title">了解IC📡</li><li class="chapter-item "><a href="../1.了解IC/1.了解IC.html">了解IC</a></li><li class="chapter-item "><a href="../1.了解IC/ICP=Web3.0.html">ICP = Web 3.0</a></li><li class="chapter-item affix "><li class="part-title">核心协议⭐</li><li class="chapter-item "><a href="../2.核心协议/1.P2P层.html">P2P层</a></li><li class="chapter-item "><a href="../2.核心协议/2.共识层.html">共识层</a></li><li class="chapter-item "><a href="../2.核心协议/3.消息路由层.html">消息路由层</a></li><li class="chapter-item "><a href="../2.核心协议/4.执行层.html">执行层</a></li><li class="chapter-item "><a href="../2.核心协议/相关概念介绍/简介.html">相关概念</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../2.核心协议/相关概念介绍/共识委员会数量如何确定？.html">共识委员会数量如何确定？</a></li><li class="chapter-item "><a href="../2.核心协议/相关概念介绍/P2P层是如何降低恶意攻击的？.html">P2P层是如何降低恶意攻击的？</a></li></ol></li><li class="chapter-item "><li class="part-title">链钥密码学🪄</li><li class="chapter-item "><a href="../3.链钥密码学(ChainKey)/1.ChainKey.html">Chain Key</a></li><li class="chapter-item "><a href="../3.链钥密码学(ChainKey)/VetKeys.html">VETKeys</a></li><li class="chapter-item affix "><li class="part-title">容器🧰</li><li class="chapter-item "><a href="../4.容器(Canister)/1.Canister.html">Canister</a></li><li class="chapter-item "><a href="../4.容器(Canister)/2.Motoko.html">Motoko</a></li><li class="chapter-item "><a href="../4.容器(Canister)/3.部署自己的Canister.html">部署Canister</a></li><li class="chapter-item "><a href="../4.容器(Canister)/4.XRC.html">XRC</a></li><li class="chapter-item affix "><li class="part-title">网络神经系统(NNS)⚙️</li><li class="chapter-item "><a href="../5.网络神经系统(NNS)/1.NNS.html">NNS</a></li><li class="chapter-item "><a href="../5.网络神经系统(NNS)/2.DAO.html">DAO</a></li><li class="chapter-item "><a href="../5.网络神经系统(NNS)/3.经济模型.html">经济模型</a></li><li class="chapter-item affix "><li class="part-title">区块链网络服务🎯</li><li class="chapter-item "><a href="../6.区块链网络服务/5.可信执行环境.html">可信执行环境</a></li><li class="chapter-item "><a href="../6.区块链网络服务/6.链上随机数.html">链上随机数</a></li><li class="chapter-item affix "><li class="part-title">互联网身份🔑</li><li class="chapter-item "><a href="../7.互联网身份/1.ii.html">互联网身份</a></li><li class="chapter-item "><a href="../7.互联网身份/3.pid.html">pid</a></li><li class="chapter-item affix "><li class="part-title">IC里的密码学🔒</li><li class="chapter-item "><a href="../8.IC里的密码学/基础密码学知识.html">基础密码学介绍</a></li><li class="chapter-item "><a href="../8.IC里的密码学/BLS签名.html">BLS</a></li><li class="chapter-item "><a href="../8.IC里的密码学/秘密共享.html">秘密共享</a></li><li class="chapter-item "><a href="../8.IC里的密码学/哈希算法.html">哈希算法</a></li><li class="chapter-item affix "><li class="part-title">开发DApp🌟</li><li class="chapter-item "><a href="../9.Dapp开发/安装开发环境.html">安装开发环境</a></li><li class="chapter-item "><a href="../9.Dapp开发/dfx常用命令.html">dfx常用命令</a></li><li class="chapter-item "><a href="../9.Dapp开发/Motoko.html">Motoko</a></li><li class="chapter-item "><a href="../9.Dapp开发/1.入门DApp.html">入门DApp</a></li><li class="chapter-item expanded "><a href="../9.Dapp开发/2.设计DApp.html" class="active">设计DApp</a></li><li class="chapter-item "><a href="../9.Dapp开发/3.开发Proton.html">开发Proton</a></li><li class="chapter-item "><a href="../9.Dapp开发/4.User模块.html">User模块</a></li><li class="chapter-item "><a href="../9.Dapp开发/5.Post模块.html">Post模块</a></li><li class="chapter-item "><a href="../9.Dapp开发/6.Feed模块.html">Feed模块</a></li><li class="chapter-item "><a href="../9.Dapp开发/7.Fetch模块.html">Fetch模块</a></li><li class="chapter-item "><a href="../9.Dapp开发/8.共享类型.html">共享类型</a></li><li class="chapter-item "><a href="../9.Dapp开发/9.完成.html">完成</a></li><li class="spacer"></li><li class="chapter-item affix "><a href="../词汇表.html">词汇表</a></li><li class="chapter-item affix "><a href="../贡献者名单.html">贡献者名单</a></li><li class="chapter-item affix "><a href="../参考资料.html">参考资料</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">互联网计算机漫游指南</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/NeutronStarDAO/ConstellationBook-Chinese" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');

                    // Get viewed page store
                    var viewed_key = 'mdbook-viewed';
                    var viewed_map = {};
                    try {
                        var viewed_storage = localStorage.getItem(viewed_key);
                        if (viewed_storage) {
                            viewed_map = JSON.parse(viewed_storage)
                        }
                    } catch (e) { }

                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                        
                        // Apply viewed style
                        if (viewed_map[link.pathname]) {
                            link.classList.add('md-viewed')
                        }
                    }); 

                    // Mark viewed after 30s
                    setTimeout(function() {
                        viewed_map[location.pathname] = 1;
                        localStorage.setItem(viewed_key, JSON.stringify(viewed_map));
                    }, 30000)
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h2 id="proton"><a class="header" href="#proton">Proton</a></h2>
<blockquote>
<p>慢即是快。</p>
<p>去中心化。</p>
</blockquote>
<p>现在我们在 Actor 模型中设计一个去中心化社交媒体。</p>
<p>我叫它 Proton 。我们面向未来设计。</p>
<div class="center-image">
<img src="assets/2.设计DApp/2.png" alt="2" style="zoom:37%;" />
</div>
<p>互联网计算机（IC）是底层设计成去中心化的云服务，底层去中心化就代表：我们部署的网站服务、智能合约
<span class="hover-win0">
<span class="hover-win2">
但是如果违背了全社区的意愿，并引起公愤，可能被 DAO 投票关掉
</span>
<span class="hover-win1">
不会被某些人随意关掉。
</span>
</span></p>
<p>上层部署的应用可以由我们自己掌控，储存自己的私人数据。也可以选择通过 DAO 来控制，变成完全去中心化的 DApp ，社区自治。</p>
<p><a href="4.%E5%AE%B9%E5%99%A8(Canister)/1.Canister.html">IC 的智能合约</a>是一种 Wasm 容器，叫 Canister ，类似于云服务的小型服务器，功能强大，可以直接提供计算、储存、托管网页、HTTP 外调（预言机）、WebSocket 等服务。</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231220212333608.png" style="zoom:40%;" />
</div>
<p>Canister 通过 Motoko 或 Rust 实现了 Actor 编程模型，我们首先需要理解 Actor 模型的基本原理。Actor 模型是一种并发计算模型，它通过消息传递和异步处理来实现并行和分布式计算。</p>
<p>所以在设计 DApp 时，应该让每个 Canister 负责不同的功能模块。比如一部分 Canister 负责记录用户资料、一部分 Canister 负责存储帖子。</p>
<p>另外，还要注重 Canister 的可扩展性，我们可以动态创建同一种 Canister 应对高负载的情况。</p>
<br>
<h2 id="设计理念"><a class="header" href="#设计理念">设计理念</a></h2>
<p>我们要构建一个真正开放的 Web3 DApp ，它是基于 Actor 模型的模块化数据主权。</p>
<p>我们希望每个用户都有自己独立的空间（Feed Canister），完全由自己掌控。<strong>用户只要跟自己的 Canister 交互就行，后续的推送都由 Canister 们协作慢慢自动完成。</strong></p>
<br>
<p>用户甚至可以直接用代码中部署自己独立的 Feed Canister 与 Proton 交互。（这做起来很麻烦，只适合程序员用户，他们可以为容器开发高级自定义功能）这允许社区创建自定义高级功能。</p>
<p><strong>Feed 是每个人的服务终端，人们可以随意切换自己的 Feed 和前端页面。社区可以开发各种自定义前端页面和 Feed 。</strong></p>
<p>它的吸引力在于个人 Canister 的隐私性和自定义的自由。越早部署，随时间积累的内容越多。</p>
<br>
<p>本质上这是一个公共发贴空间。该架构是为任何想在去中心化网络上发布内容的人设计的。</p>
<p><strong>这里没有 “ 边界 ” 的概念。它不再是一个孤立的数据岛屿；人们可以自由发布和访问内容。</strong></p>
<p><strong>它的存在超越了任何单个应用程序；它可以代表去中心化互联网上的所有平台。</strong></p>
<p><strong>如果人们想在去中心化网络上发布内容，他们可以选择在像这样的公共空间中进行，而不是在 “ X ” 、“ Reddit ” 或 “ Quora ” 等平台上发布。</strong></p>
<p>这里没有实体控制；内容至上，个人主权至高无上。</p>
<br>
<h2 id="思路"><a class="header" href="#思路">思路</a></h2>
<p>首先是有一个可扩展的公共区（Public Area）接收所有用户发的帖子，有一个用户区记录用户注册、个人资料、关注关系。</p>
<p>我们给每位用户创建一个 Feed ，用来存储用户自己的信息流，Feed 也是用户自己的私人空间，用户可以将帖子保存在自己的 Canister 里（Feed），除了自己没人能删除它。</p>
<br>
<p><strong>用户与公共区的交互都由 Feed 这个 Canister 自动完成，用户只要查询自己的 Feed 就可以获取关注的最新信息流。发帖、评论、点赞这些交互也都由 Feed 自动完成后面的操作。</strong></p>
<div class="center-image">
<img src="assets/2.设计DApp/0bcc2cec4ca809863960105155fde056af3cd414.png" alt="img" style="zoom:51%;" />
</div>
<p>用户也可以增加几个高级自定义功能，自己部署一个独立的 Feed 与公共区交互。比如只把帖子点对点发送给某几个 Feed ，建立私密小社交圈子；或者只连接 AI 实现自动发帖等等。任何功能都可以实现，社区可以二次开发，随意拓展各种功能。比如增加一个点对点的私信功能。</p>
<br>
<h2 id="消息传输流程"><a class="header" href="#消息传输流程">消息传输流程</a></h2>
<p>在用户发帖时，Feed 先把帖子存在自己的信息流中，然后把帖子按照粉丝列表点对点依次发给粉丝的 Feed 和公共区的 Bucket 。但是如果有一万个粉丝呢，情况不太好，因为 Canister 之间收发消息受 max input / out queue size 限制，一次性发不了那么多。Feed 得分批次发送很长时间才能发完。</p>
<p>为了增加吞吐量，我们加一个消息中转站：Fetch 。Feed 先把帖子发给公共区，再把帖子 ID 、粉丝发给 Fetch 。Fetch 记录以后，再根据算法依次通知这些粉丝的 Feed 要抓取哪些帖子，最后 Feed 去公共区抓取帖子。</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231121215915409.png" style="zoom:50%;" />
</div>
<p>这样即使粉丝很多，也可以在 Fetch 的调节下依次从公共区抓取帖子。</p>
<br>
<p>这是一个完全开放的，消息传递稍慢一点的去中心化应用。这种设计为了去中心化牺牲了一点速度，就像比特币一样。</p>
<p><strong>优点是用户的前端只要查询自己的 Feed 就可以获取关注的人的帖子。方便快速，后台的一切由 Canister 之间去中心化协作完成，完全解耦。</strong> 几个 Canister 挂掉之后不影响这个系统的继续运行。（ Fetch 挂了可以再创建几个）</p>
<p>如果系统暂时无法恢复， Feed 可以点对点直接用 ignore call 分批次给粉丝发送帖子。也就是说，Feed 里内置了两套发贴流程：通过 Fetch 中转站发帖，以及点对点发帖。只是点对点发帖会更慢一点。</p>
<br>
<p>好的，说了这么多，现在详细说明一下这种架构吧。</p>
<br>
<h2 id="架构"><a class="header" href="#架构">架构</a></h2>
<p>基于 Actor 模型的点对点分布式<strong>推送-抓取</strong>架构。</p>
<br>
<p>总体上，你可以将 Proton 分为四个模块：User 、Feed 、Post 、Fetch 。</p>
<ul>
<li><strong>User</strong> ：用户区，负责记录用户信息和关系。这里记录了用户的个人资料和关注关系。</li>
<li><strong>Post</strong> ：公共区，存储所有公开发布的帖子。Root Post 可以创建许多 Bucket 存储帖子。</li>
<li><strong>Feed</strong> ：信息流，存储用户的个人信息流。Root Feed 会为每个用户创建一个 Feed 。</li>
<li><strong>Fetch</strong> ：中转站，负责推送某个用户的最新信息流。这里记录了用户的 Feed 未抓取的帖子、评论或点赞。</li>
</ul>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231117210909667.png" style="zoom:39%;" />
</div>
<p>用户可以关注别人（和取消关注），查看公共区最新发布的帖子（所有人发的帖子）、查看自己的信息流（关注的人和自己发的帖子），发帖、转发，评论、点赞、收藏（和取消收藏）。</p>
<br>
<h3 id="user"><a class="header" href="#user">User</a></h3>
<p>用户区，负责记录用户信息和关系。这里记录了用户的个人资料和关注关系。</p>
<p>User canister 里记录用户的基本信息。比如 UserId 、名称、公司、学校、职业、个人简介、关注关系、自己的 Feed Canister ID 等等。</p>
<p>用户可以调用这里的函数关注某人、更新自己的资料，或者查询自己关注了谁、某人的关注关系。</p>
<p>用户新关注了人或者有新人关注，要通知用户的 Feed 更新列表。</p>
<br>
<h3 id="post"><a class="header" href="#post">Post</a></h3>
<p>公共区，存储所有公开发布的帖子。Root Post 可以创建许多 Bucket 存储帖子。</p>
<br>
<h4 id="root-post"><a class="header" href="#root-post">Root Post</a></h4>
<p>公共区负责存储所有公开发布的帖子。</p>
<p>Root Post 可以创建许多 Bucket Canister 来存储帖子。</p>
<p>Root Post 有创建 Bucket 功能、查询可用的 Bucket 是谁、查询所有 Bucket 、查询已存满的 Bucket 。</p>
<br>
<p>Root Post 开始先创建 5 个 Bucket 。有一个 Bucket 存满后，再创建一个 Bucket ，始终保持有 5 个可用的 Bucket 。</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231120173647549.png" style="zoom:37%;" />
</div>
<p>在用户刚打开前端界面的时候，后台的 Feed 就立刻向 Root Post 去查询可用的 Bucket 是哪个。Root Post 随机返回一个 Bucket ，Feed 里存着一个 “ 可用的 Bucket ” 的变量，查到 Canister ID 之后更新这个变量。</p>
<ul>
<li>
<p>调用 Bucket 的查询最新的 5 个帖子，获取公开的最新帖子。</p>
</li>
<li>
<p>当用户向公共区发帖时，调 Bucket 存储帖子。</p>
</li>
</ul>
<p>当某个用户的 Feed 从 Fetch 那里获取到一大堆帖子 ID 后，就可以提供帖子 ID 向 Bucket 查询帖子了。</p>
<br>
<h4 id="bucket"><a class="header" href="#bucket">Bucket</a></h4>
<p>Bucket 可以<strong>增查</strong>帖子。</p>
<p>其中查询有 3 个函数，分别是查询这个 Canister 一共有多少个帖子、根据 ID 查询某几个帖子（可以传入 7 个 ID 一次性返回 7 个帖子的内容）、查询最新的 n 个帖子（调用时传参告诉它要查最新的多少个帖子）。</p>
<p>精确查询帖子和查询最新的几个帖子时，需要返回帖子本身和目前的点赞、评论数。</p>
<br>
<p>Bucket 负责接收帖子、评论、点赞。</p>
<p>Bucket 在接收新帖子时，先看一下帖子 ID 有没有冲突，没冲突才接收。</p>
<p>并把有评论、点赞更新的帖子 ID 通知给 Comment Fetch 、Like Fetch 。</p>
<br>
<h3 id="feed"><a class="header" href="#feed">Feed</a></h3>
<p>信息流，存储用户的个人信息流。Root Feed 会为每个用户创建一个 Feed 。</p>
<br>
<h4 id="root-feed"><a class="header" href="#root-feed">Root Feed</a></h4>
<p>Root Feed 负责给用户创建一个用户自己的 Canister ，并记录总共创建了多少个 Canister 和它们的 Canister ID 是多少。</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231120185518041.png" style="zoom:39%;" />
</div>
<br>
<h4 id="feed-1"><a class="header" href="#feed-1">Feed</a></h4>
<p><strong>用户通过自己的 Feed 参与 Proton 中的交互：查看、发帖、评论、点赞等等，都通过 Feed 进行。</strong></p>
<br>
<p>用户自己的 Feed 里记录着粉丝（用来推送帖子、评论、点赞）、following （接收帖子时检测）、信息流（只保存最新的 3000 个帖子）、保存的帖子（上限是保存 500 个帖子）。</p>
<br>
<p>每个帖子都有发布时间、发布者的用户 ID <code>UserId</code> 、帖子 ID <code>PostId</code> 和转发人 ID <code>RepostId</code> （没转发就是空）。</p>
<br>
<p>帖子 ID 是 Bucket Canister ID 加 UserId 加自增，这样每个用户都可以直接创建直接的帖子 ID ，不需要与 Bucket 沟通帖子 ID 是什么。</p>
<p>比如 aaaaa-aaa-bbbbb-bbb-1 、aaaaa-aaa-bbbbb-bbb-2 、aaaaa-aaa-bbbbb-bbb-3 ... </p>
<br>
<p>查帖：</p>
<p>有 3 个函数可以查询 Feed 里的帖子：查询一共有多少个帖子（统计总数）、根据帖子 ID 查询某个帖子、查询最新的 n 个帖子（调用时传参告诉 Feed 要查最新的多少个帖子）。</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231120172645581.png" style="zoom:35%;" />
</div>
<br>
<p>发帖：</p>
<p>当用户 A 发布一条新帖子时，前端会发送帖子到用户 A 的 Feed 里。</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231116235638531-1700192647376-9.png" style="zoom:40%;" />
</div>
<p>Feed 接收到消息后，会创建一个新帖子存储起来。</p>
<p>然后将帖子内容发送给公共区的 Bucket ，存储到公共区，所有人都能看到。并把发帖人、帖子 ID 、用户 C 、D（粉丝）发送给 Fetch 。</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231117004133644-1700192647376-8.png" alt="image-20231117004133644" style="zoom:37%;" />
</div>
<p>Fetch 会记录下来，并一个个通知用户 C 、D 的 Feed 去根据帖子 ID 抓取内容。Fetch 发出通知之后就删除 user C 和帖子 ID ，Fetch 里存的都是 “ 待通知 ” 的记录。</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231117004213850-1700192647376-10.png" alt="image-20231117004213850" style="zoom:50%;" />
</div>
<p>用户 C 、D 的 Feed 在收到要抓取的帖子 ID 后，会从公共区将对应帖子添加到自己 Feed 的帖子流中。（在这个例子里，用户 C 将收到 ID 为 1 、6 、7 、15 的帖子，用户 C 的 Feed 去 Bucket 里抓取帖子 1 、6 、7 、15 ）</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231117005218488-1700192647376-11.png" alt="image-20231117005218488" style="zoom:50%;" />
</div>
<p>用户 C 、D 打开前端查询自己 Feed 时，就能看见 A 发的新帖子，从而能够在第一时间获取最新的帖子。</p>
<br>
<p>如果后来用户 E 关注了用户 A ，那么他的 Feed 只会接收用户 A 的新帖子。</p>
<br>
<p><strong>前端只要发送一次请求即可，后续的推送工作（比如通知公共区的操作）都由 Canister 完成。</strong></p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231120171812860.png" style="zoom:33%;" />
</div>
<p>当用户数量增多时，一个 Fetch 可能处理不过来大量发帖请求，这时可以创建一个新的 Fetch 推送消息，可以根据需要水平扩展中转站服务。</p>
<br>
<p>删帖：</p>
<p>不可删贴，区块链：一发不可收拾。</p>
<p>不管粉丝的 Feed 里的帖子了，反正只保留最新的 3000 条帖子。（另外，Feed 是人家的私人空间）</p>
<br>
<p>转发：</p>
<p>用户 C 把帖子转发给 H 、I 、J 、K ： <code>转发人：C</code> 、<code>帖子 ID ：post15_id</code> 、<code>粉丝：用户 H 、I 、J 、K</code> ，发给 Fetch 。</p>
<p>Fetch 记录下来，通知 H 、I 、J 、K 的 Feed 。</p>
<p>这些 Feed 去公共区根据 ID 抓取帖子。</p>
<blockquote>
<p>当用户 C 转发帖子时，发布者是用户 A 保持不变，转发人是用户 C 。</p>
</blockquote>
<br>
<p>评论：</p>
<p>评论流程与发帖流程类似，通过 Comment Fetch 进行评论。</p>
<p>看见帖子的任何人（user X）都可以评论。前端调用 Feed ，传入 post_id 、评论内容。</p>
<p>Feed 收到评论后，先根据帖子 ID 查找自己的 3000 条信息流里有没有这个帖子，有的话就给 Feed 里的这个帖子添加评论。</p>
<p>然后通知公共区的 Bucket 更新评论。</p>
<p>公共区的 Bucket 收到评论之后，Bucket 会通知 Comment Fetch 是哪个帖子有新评论了（帖子 ID ）。</p>
<p>Comment Fetch 先去 User 用户区获取发帖人的粉丝是哪些人，没找到这个发帖人就拒绝请求。</p>
<p>然后把帖子 ID 、发帖人和粉丝添加到 “ 待通知 ” 列表里。</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231129154312702.png" alt="image-20231129154312702" style="zoom:33%;" />
</div>
<p>在 Comment Fetch 依次发出通知之后，粉丝根据 Comment Fetch 提供的帖子 ID 去查询帖子的所有评论，把新评论更新到自己的 Feed 里。</p>
<br>
<p>如果粉丝 D 转发过这个帖子，D 的 Feed 在收到新评论通知后，会继续向 Comment Fetch 通知：post15_id 、D 的粉丝。</p>
<p>不能删除评论。</p>
<br>
<p>点赞：</p>
<p>点赞流程与发帖流程类似，通过点赞 Like Fetch 进行。</p>
<p>看见帖子的任何人（user X）都可以点赞，公共区的 Bucket 收到点赞之后，Bucket 会通知 Like Fetch 是哪个帖子有新点赞了（帖子 ID ）。</p>
<p>Like Fetch 先去 User 用户区获取发帖人的粉丝是哪些人，没找到这个发帖人就拒绝请求。</p>
<p>然后把帖子 ID 、发帖人和粉丝添加到 “ 待通知 ” 列表里。</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231120161143485.png" style="zoom:33%;" />
</div>
<p>在 Like Fetch 依次发出通知之后，粉丝根据 Like Fetch 提供的帖子 ID 去查询帖子的点赞数，把点赞数更新到自己的 Feed 里。</p>
<br>
<p>如果粉丝 D 转发过这个帖子，D 的 Feed 在收到新点赞通知后，会继续向 Comment Fetch 通知：post15_id 、D 的粉丝。</p>
<p>不能删除点赞。</p>
<br>
<h3 id="fetch"><a class="header" href="#fetch">Fetch</a></h3>
<p>负责接收所有人的发帖、评论、点赞消息，并把消息通知给相关的 Feed 。</p>
<br>
<h4 id="root-fetch"><a class="header" href="#root-fetch">Root Fetch</a></h4>
<p>Root Fetch 根据用户数量动态创建多个 Fetch 。它可以创建 3 种 Fetch ：Post Fetch 、 Like Fetch 、Comment Fetch 。还可以通过 Root Fetch 查询有哪些 Fetch 是可用的。</p>
<br>
<h4 id="post-fetch"><a class="header" href="#post-fetch">Post Fetch</a></h4>
<p>接收发帖人的通知：帖子 ID 、发帖人、转发人、粉丝、Cycles 。</p>
<p>内部维护一个通知表：记录每个用户待通知的帖子 ID 有哪些。</p>
<p>根据算法用 ignore call 分批次通知粉丝的 Feed 。</p>
<br>
<h4 id="comment-fetch"><a class="header" href="#comment-fetch">Comment Fetch</a></h4>
<p>接收 Bucket 发的新评论通知：帖子 ID 、发帖人（A）、转发人（空）。</p>
<p>根据发帖人（或转发人）到 User 用户区获取发帖人的粉丝。</p>
<p>内部维护一个通知表：记录每个用户待通知的帖子 ID 有哪些。</p>
<p>根据算法用 ignore call 分批次通知粉丝的 Feed 。</p>
<p>如果某个粉丝 C 转发过这个帖子，C 的 Feed 在收到新评论通知后，会继续向 Comment Fetch 发送通知：帖子 ID 、发帖人（A）、转发人（C）。</p>
<br>
<h4 id="like-fetch"><a class="header" href="#like-fetch">Like Fetch</a></h4>
<p>接收 Bucket 发的新点赞通知：帖子 ID 、发帖人（A）、转发人（空）。</p>
<p>根据发帖人（或转发人）到 User 用户区获取发帖人的粉丝。</p>
<p>内部维护一个通知表：记录每个用户待通知的帖子 ID 有哪些。</p>
<p>根据算法用 ignore call 分批次通知粉丝的 Feed 。</p>
<p>如果某个粉丝 C 转发过这个帖子，C 的 Feed 在收到新点赞通知后，会继续向 Like Fetch 发送通知：帖子 ID 、发帖人（A）、转发人（C）。</p>
<br>
<p>以上的 User 、Post 、Fetch 、Feed 构成了 Proton 的基础架构。</p>
<br>
<p>在这个架构基础上，我们可以想象一下模块化 Actor 模型带来的更多优势 ... </p>
<br>
<h3 id="一切都由用户自己选择"><a class="header" href="#一切都由用户自己选择">一切都由用户自己选择</a></h3>
<p>用户可以选择通过 Feed 点对点私密发送帖子给某几个粉丝的 Feed ，而不公开发布。</p>
<p>用户也可以建立自己的 “ 社区服务器 ” ，就是一个自己控制的社区公共区。这样人们的 Feed 可以订阅这个社区服务区，Feed 每隔 2 小时向社区服务器请求更新信息。Feed 里保存着上一次更新的 post id ，Feed 请求时，传入上一次的 post id ，社区服务器就会找出自上一次更新的帖子返回给 Feed 。</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231220175917344.png" style="zoom:80%;" />
</div>
<p>整个系统都是模块化的，都可以由社区去自发地构建。比如用户可以建立自己的一个社区服务器、广播矩阵等等。（广播矩阵后面介绍）</p>
<br>
<h3 id="自动调节压力"><a class="header" href="#自动调节压力">自动调节压力</a></h3>
<p>Fetch 累积了一定的消息之后，通过算法调整通知的顺序和间隔（先通知哪个 Feed 和每通知几个 Feed 之后间隔多少毫秒再通知其他 Feed ），保证公共区的查询压力不能太高。Feed 在收到通知后，如果抓取失败，应该等 20 秒再抓取。</p>
<br>
<p>如果公共区面临的查询压力太大，就会告诉 Root Fetch ：“ 慢一点通知 Feed ” ，Root Fetch 会通知它下面的几个 Fetch 减小通知频率。如果 10 分钟后压力依然很大，Root Post 也可以再创建一个 Bucket ，让新帖子发到新 Bucket 里。</p>
<p>而且如果用户增多以后，Fetch 本身也可以根据需要增添。</p>
<br>
<p>因为只要 Feed 发送一条信息，Fetch 就得通知很多个其他的 Feed 。这样开放的环境中，很容易造成 Dos 攻击。所以在 Feed 把信息发给 Fetch 时，需要交一笔 Gas 费，收到 Gas 费之后 Fetch 才会把信息放进 “ 待通知 ” 列表。</p>
<br>
<h3 id="广播矩阵"><a class="header" href="#广播矩阵">广播矩阵</a></h3>
<p>假如有 1000 个人在 2 分钟内对帖子 15 点赞，Fetch 仍然只需要通知帖子 15 的粉丝一次就可以。然后这些粉丝自己去公共区的 Bucket 里查现在到底有多少个点赞。</p>
<blockquote>
<p>当然，Fetch 也可以记录下来哪个帖子有多少个点赞、该通知谁，积累一定时间之后，然后直接通知粉丝的 Feed ：某个帖子有 1000 个点赞。这样 Feed 就不需要去 Bucket 里查点赞数了，Fetch 里都记录好了。</p>
<p>但是这样也更中心化，所有 Feed 都听 Fetch 的指挥，直接相信 Fetch 给的点赞数。如果 Fetch 被控制，就有可能出现虚假的点赞数，所以让 Feed 自己去 Bucket 里查才是最真实的。</p>
</blockquote>
<br>
<p>现在我们来想想高并发的场景：假 如 Fetch 要通知 1 万个 Feed ，但是由于 Canister 系统的消息队列限制，假设一个 Fetch 一次只能向 500 个 Feed 发送通知。</p>
<p>如果只有一个 Fetch 工作，需要 20 次才能通知完。这时就需要多个 Fetch 协作了。</p>
<p>一个 Fetch 先把要通知的用户列表分成 5 份，然后分发给 5 个 Fetch ，这样一次性就可以发送 2500 个通知，只要 4 次即可完成推送！</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231224001103346.png" style="zoom:37%;" />
</div>
<p>Canister 的消息输出队列是 500 ，所以我们可以建立不同发送能力的中转站：500 ，2500 ，5000 ，10000 ... </p>
<p>一个 Canister 一次可以发送 500 个消息，五个 Canister 一次可以发送 2500 个消息，十个 Canister 一次可以发送 5000 个消息，二十个 Canister 一次可以发送 10000 个消息。</p>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231201010601827.png" style="zoom:51%;" />
</div>
<p>保险起见，实际使用时，我们应该留出一部分消息输出，保证其他通信正常以及紧急情况时呼叫联系 Root Fetch 的消息输出，所以应该设置一个 Fetch 一次最多发送 430 条通知。</p>
<p>为了防止 Dos 攻击，用户每次发帖、评论、点赞时，应该同时发送一些 Cycles 才行。使用不同种类的广播矩阵收费也不同。</p>
<p>如果某个人的粉丝特别多，他也可以选择不相信别人任何人，自己建立一个私人广播矩阵。用作专门给自己的粉丝通知消息。</p>
<br>
<p>不过这些是未来的规划，现在我们先把大框架设计好，有了基本功能之后再持续优化细节。</p>
<br>
<h2 id="规划"><a class="header" href="#规划">规划</a></h2>
<p><strong>最终规划：模块化、公共数据库、用户云终端。</strong></p>
<p>模块化：将 Canister 按照功能分类，各司其职。</p>
<p>公共数据库：开放的数据库，任何人都可以直接发布和获取内容。</p>
<p>用户云终端：每个用户有自己的独立服务器（Canister），提供链上私人服务。</p>
<br>
<h2 id="做"><a class="header" href="#做">做</a></h2>
<p>这是一个复杂、庞大的大型应用。</p>
<p>在这个教程中，我们将使用 Motoko 构建这个 DApp 的基础功能。</p>
<p>🆗 <a href="">Let’s go!</a> 🆗</p>
<br>
<div class="center-image">
<img src="assets/2.设计DApp/image-20231220222254067.png" style="zoom:50%;" />
</div>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../9.Dapp开发/1.入门DApp.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../9.Dapp开发/3.开发Proton.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../9.Dapp开发/1.入门DApp.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../9.Dapp开发/3.开发Proton.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="../ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="../editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="../theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "9.Dapp开发/2.设计DApp.md"
        </script>


        <!-- Custom JS scripts -->
        <script type="text/javascript" src="../assets/custom.js"></script>
        <script type="text/javascript" src="../assets/bigPicture.js"></script>


    </body>
</html>